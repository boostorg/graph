<HTML>
<!--
  Copyright (c) 2014 Stefan Hammer, University of Vienna
  Copyright (c) 2014 Jakob Lykke Andersen, University of Southern Denmark
  
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
  -->
<Head>
<Title>Boost Graph Library: Ear Decomposition</Title>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
        ALINK="#ff0000"> 
<IMG SRC="../../../boost.png" 
     ALT="C++ Boost" width="277" height="86"> 

<BR Clear>

<TT>ear_decomposition</TT>
</H1>

<P>
<PRE>
<!--TODO <i>// named parameter version</i>
template &lt;class Graph, class class P, class T, class R&gt;
void ear_decomposition(Graph&amp; G,
  const bgl_named_params&lt;P, T, R&gt;&amp; params);
-->
<i>// non-named parameter versions</i>
template &lt;class Graph, class PredMap, class DistanceMap, class EarMap&gt;
void ear_decomposition(const Graph&amp; g, PredMap pred, DistanceMap dist, EarMap ear);
</PRE>

<p>
The <tt>ear_decomposition</tt> decomposes blocks of an undirected graph <tt>G</tt> into a sequence of ears. An ear is a path or a cycle where the endpoints of the path may coincide with the remaining graph, but where otherwise no repetition of edges or vertices is allowed. In other words, the endpoints of an ear always belong to an earlier ear in the sequence of ears, but the internal vertices of the path or cycle do not belong to any earlier ear.
<br>
In most cases the first ear in the sequence is a cycle. The <tt>ear_decomposition</tt> is called <tt>open</tt> if it does not allow the removal of cycles as ears.

<p><center><img style="padding:20px; height:250px;" src="figs/ear_decomposition.svg"></center>

The input for this algorithm is an undirected graph, which has to consist of a single <a href="biconnected_components.html">biconnected component</a>, a spanning tree in form of a <tt>predecessor_map</tt>, and optionally a map containing the distances of each vertex to the root of the spanning tree.
The output of the <tt>ear_decomposition</tt> records the ear number of each edge in the property map <tt>ear</tt>. If a certain edge is not present in any ear, its ear number will zero.
<br>
The algorithm used in this approach is described by Maon et. al [<a href="bibliography.html#maonschiebervishkin86">74</a>].
You can retrieve the spanning tree by, for example, using the <a href="random_spanning_tree.html"><tt>random_spanning_tree()</tt></a> algorithm.
</p>

<H3>Where Defined</H3>

<P>
<a href="../../../boost/graph/ear_decomposition.hpp"><TT>boost/graph/ear_decomposition.hpp</TT></a>

<h3>Parameters</h3>

IN: <tt>const Graph&amp; g</tt>
<blockquote>
  An undirected, unweighted graph. The graph type must
  be a model of <a href="./IncidenceGraph.html">Incidence Graph</a> and should consist of a single <a
  href="biconnected_components.html">biconnected component</a>.<br>
</blockquote>

<!-- TODO <h3>Named Parameters</h3> -->

IN: <tt><!--predecessor_map(-->PredMap pred<!--)--></tt>
<blockquote>
  This map has to contain the predecessor of each vertex in the graph
  of an arbitrary spanning tree <tt>T</tt>.  The value
  <tt>graph_traits&lt;Graph&gt;::null_vertex()</tt> has to be used as the
  predecessor of the root of the tree.  The type <tt>PredMap</tt> must be a
  model of <a 
  href="../../property_map/doc/ReadablePropertyMap.html">Readable Property
  Map</a>. The key and value types of the map must both be the graph's vertex type.<br>
</blockquote>

UTIL: <tt><!--distance_map(-->DistanceMap dist<!--)--></tt>
<blockquote>
  This map contains the tree-edge distance of each vertex in the spanning tree <tt>T</tt> to the <tt>root</tt> vertex.
  The <tt>DistanceMap</tt> type must be a model of <a
  href="../../property_map/doc/ReadablePropertyMap.html">Readable Property
  Map</a>. The value type shouch be an integer type, the key type must be
  the graph's vertex descriptor type.<br>
  <b>Default</b>: <tt>vector_property_map</tt>.<br>
</blockquote>

OUT: <tt><!--ear_map(-->EarMap ear<!--)--></tt>
<blockquote>
  The algorithm decomposes the block into a sequence of ears and labels every edge with the according ear number 
  between 1 and the amount of cycles in the block. It assignes 0 to edges not included in any ears.
  The last ear usually is a cycle, while the others are paths.
  The <tt>EarMap</tt> type must be a model of <a
  href="../../property_map/doc/ReadWritePropertyMap.html"> Read/Write Property
  Map</a>. The value type should be an integer type, preferably the same
  as the <tt>edges_size_type</tt> of the graph. The key type must be
  the graph's edge descriptor type.<br>
</blockquote>

<H3>Example</H3>

<P> The file <a
href="../example/ear_decomposition.cpp"><tt>examples/ear_decomposition.cpp</tt></a>
contains an example of the <tt>ear_decomposition()</tt> given a random spanning tree on a simple graph block.

<br>
<HR>
<TABLE>
<TR valign=top>
<TD nowrap>Copyright &copy; 2014</TD><TD>
<A HREF="http://homepage.univie.ac.at/s.hammer/">Stefan Hammer</A>,
University of Vienna (<A
HREF="mailto:s.hammer@univie.ac.at">s.hammer@univie.ac.at</A>)<br>
<A HREF="http://imada.sdu.dk/~jlandersen/">Jakob Lykke Andersen</A>, University of Southern Denmark  (<A HREF="mailto:jlandersen@imada.sdu.dk">jlandersen@imada.sdu.dk</A>)
</TD></TR></TABLE>

</BODY>
</HTML> 

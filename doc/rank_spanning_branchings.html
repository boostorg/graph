<HTML>
<!--
     Copyright (c) Bradley S. Meyer 2015
    
     Distributed under the Boost Software License, Version 1.0.
     (See accompanying file LICENSE_1_0.txt or copy at
     http://www.boost.org/LICENSE_1_0.txt)
  -->
<Head>
<Title>Boost Graph Library: Rank Spanning Branchings</Title>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
        ALINK="#ff0000"> 
<IMG SRC="../../../boost.png" 
     ALT="C++ Boost" width="277" height="86"> 

<BR Clear>


<H1><A NAME="sec:rank_spanning">
<img src="figs/python.gif" alt="(Python)"/>
<TT>rank_spanning_branchings</TT>
</H1>

<PRE>
template &lt;class Graph, class BranchingProcessor, class P, class T, class R&gt;
void
rank_spanning_branchings(Graph&amp; g, BranchingProcessor fn, 
    const bgl_named_params&lt;P, T, R&gt;&amp; params = <i>all defaults</i>);
</PRE>

<P>
The <tt>rank_spanning_branchings()</tt> function finds, in order by branching
weight, the spanning branchings in a directed graph with weighted edges.
If a directed graph has size <tt>N</tt>, a spanning branching is an
acyclic subgraph of 
that graph with <tt>N-1</tt> edges such that no vertex has indegree larger than
one.  The weight of the branching is the sum of the weights of the edges
in the branching.
This function uses the Camerini et al. algorithm to compute the
branchings in order by branching weight.  Once the routine finds a branching,
the routine calls a user-supplied 
<a href="./rank_spanning_branchings.html#concept:BranchingProcessor">BranchingProcessor</a>
to process the branching and then
move on to find the next branching.  The
user-supplied
<a href="./rank_spanning_branchings.html#concept:BranchingProcessor">BranchingProcessor</a>
must take as
input a pair of iterators (begin, end) to allow iteration over the edges
in the branching.
[<A
HREF="bibliography.html#kruskal56">18</A>,<A
HREF="bibliography.html#clr90">8</A>,<A
HREF="bibliography.html#tarjan83:_data_struct_network_algo">27</A>,<A
HREF="bibliography.html#graham85">15</A>].
</p>
<p>
Kruskal's algorithm starts with each vertex in a tree by itself, and
with no edges in the minimum spanning tree <i>T</i>. The algorithm
then examines each edge in the graph in order of increasing edge
weight. If an edge connects two vertices in different trees the
algorithm merges the two trees into a single tree and adds the edge to
<i>T</i>. We use the ``union by rank'' and ``path compression''
heuristics to provide fast implementations of the disjoint set
operations (<tt>MAKE-SET</tt>, <tt>FIND-SET</tt>, and
<tt>UNION-SET</tt>).  The algorithm is as follows:
</p>

<pre>
KRUSKAL-MST(<i>G</i>, <i>w</i>) 
  <i>T := &Oslash;</i> 
  <b>for</b> each vertex <i>u in V</i> 
    MAKE-SET(<i>DS</i>, <i>u</i>) 
  <b>end for</b>
  <b>for</b> each edge <i>(u,v) in E</i> in order of nondecreasing weight 
    <b>if</b> FIND-SET(<i>DS</i>, <i>u</i>) != FIND-SET(<i>DS</i>, <i>v</i>) 
      UNION-SET(<i>DS</i>, <i>u</i>, <i>v</i>) 
      <i>T := T U {(u,v)}</i> 
  <b>end for</b>
  <b>return</b> <i>T</i>
</pre>


<H3>Where Defined</H3>

<P>
<a href="../../../boost/graph/rank_spanning_branchings.hpp"><TT>boost/graph/rank_spanning_branchings.hpp</TT></a>

<P>

<h3><A NAME="concept:BranchingProcessor">
<tt>BranchingProcessor</tt>
</h3>

<p>
BranchingProcessor is used in the <tt>rank_spanning_branchings</tt> function to
process the edges in a branching.  It is a functor that can be called with
a pair of iterators.  The first iterator of the pair points to the first
edge in a branching while the second points to one past the last edge in
the branching.  The processor must return a boolean.  If the return value is
true, <tt>rank_spanning_branchings</tt> continues and seeks the next branching.
If the return value is false, <tt>rank_spanning_branchings</tt> stops.
</p>

<p>
The following functor is an example 
<a href="./rank_spanning_branchings.html#concept:BranchingProcessor">BranchingProcessor</a> that prints out the edges in a branching.
<pre>
template&lt;class Graph&gt;
struct print_branching
{
  const Graph&amp; m_g;

  print_branching( const Graph&amp; g ) : m_g( g ) {} 

  template&lt;class EdgeIterator&gt;
  bool operator()( std::pair&lt;EdgeIterator, EdgeIterator&gt; p )
  {
    std::cout << "Branching:";
    while( p.first != p.second )
    {
      std::cout << " (" << source( *p.first, m_g ) << "," << target( *p.first, m_g ) << ")";
      p.first++;
    }
    std::cout << std::endl;
    return true;
  }
};
</pre>
It returns true, so <tt>rank_spanning_branchings</tt> would always continue
on to find the next branching.
</p>

<p>
This example
<a href="./rank_spanning_branchings.html#concept:BranchingProcessor">BranchingProcessor</a> could be called on a <tt>Graph g</tt> as
<pre>
rank_spanning_branchings( g, print_branching&lt;Graph&gt;( g ) );
</pre>
This would print out all spanning branchings in the graph in descending order
by branching weight.
</p>
   
<h3>Parameters</h3>

IN: <tt>const Graph&amp; g</tt> 
<blockquote>
  An undirected graph. The graph type must be a model of
  <a href="./EdgeListGraph.html">Edge List Graph</a>.<br>

  <b>Python</b>: The parameter is named <tt>graph</tt>.
</blockquote>

</blockquote>
 IN: <tt>BranchingProcessor bp</tt>
<blockquote>
  A functor that models <a href="./rank_spanning_branchings.html#concept:BranchingProcessor">BranchingProcessor</a> to process the edges in a branching.<br>
</blockquote>



<h3>Named Parameters</h3>

IN: <tt>weight_map(WeightMap w_map)</tt> 
<blockquote>
The weight or ``length'' of
  each edge in the graph.  The <tt>WeightMap</tt> type must be a model
  of <a href="../../property_map/doc/ReadablePropertyMap.html">Readable
  Property Map</a> and its value type must be <a
  href="http://www.sgi.com/tech/stl/LessThanComparable.html">Less Than
  Comparable</a>. The key type of this map needs to be the graph's
  edge descriptor type.<br>
  <b>Default:</b> <tt>get(edge_weight, g)</tt><br>
  <b>Python</b>: Must be an <tt>edge_double_map</tt> for the graph.<br>
  <b>Python default</b>: <tt>graph.get_edge_double_map("weight")</tt>
</blockquote>

IN: <tt>vertex_index_map(VertexIndexMap i_map)</tt> 
<blockquote>
  This maps each vertex to an integer in the range <tt>[0,
  num_vertices(g))</tt>.
  The type <tt>VertexIndexMap</tt>
  must be a model of <a
  href="../../property_map/doc/ReadablePropertyMap.html">Readable Property
  Map</a>. The value type of the map must be an integer type. The
  vertex descriptor type of the graph needs to be usable as the key
  type of the map.<br>
  <b>Default:</b> <tt>get(vertex_index, g)</tt>
    Note: if you use this default, make sure your graph has
    an internal <tt>vertex_index</tt> property. For example,
    <tt>adjacenty_list</tt> with <tt>VertexList=listS</tt> does
    not have an internal <tt>vertex_index</tt> property.
   <br>

  <b>Python</b>: Unsupported parameter.
</blockquote>

IN: <tt>distance_compare(CompareFunction cmp)</tt>
<blockquote>
  This function is used to compare edge weights to determine which
  edges to include
  in the next best branching.  It is also used to compare the weights of
  branchings.  The weight of a branching is the sum of weights of its edges.
  The <tt>CompareFunction</tt> type must be a model of <a
  href="http://www.sgi.com/tech/stl/BinaryPredicate.html">Binary
  Predicate</a> and have argument types that match the value type of
  the <tt>WeightMap</tt> property map.<br>

  <b>Default:</b>
  <tt>std::less&lt;W&gt;</tt> with <tt>W=typename
  property_traits&lt;WeightMap&gt;::value_type</tt><br>

  <b>Python</b>: Unsupported parameter.
</blockquote>

<H3>Complexity</H3>

<P>
The time complexity is <i>O(E log V)</i>

<H3>Example</H3>

<P>
The files <a
href="../example/rank-branchings1.cpp"><TT>example/rank-branching1.cpp</TT></a>
and
<a
href="../example/rank-branchings2.cpp"><TT>example/rank-branching2.cpp</TT></a>
contain examples of using the Camerini et al. algorithm.

<br>
<HR>
<TABLE>
<TR valign=top>
<TD nowrap>Copyright &copy; 2015</TD><TD>
<A HREF="http://www.boost.org/people/bradley_meyer.htm">Bradley S. Meyer</A>, Clemson University (<A HREF="mailto:mbradle@clemson.edu">mbradle@clemson.edu</A>)
</TD></TR></TABLE>

</BODY>
</HTML> 

